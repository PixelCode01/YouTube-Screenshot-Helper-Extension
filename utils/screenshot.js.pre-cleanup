// Screenshot utility for YouTube Screenshot Helper

class ScreenshotManager {
  constructor() {
    this.settings = null;
    this.canvas = null;
    this.context = null;
    this.init();
  }

  async init() {
    this.settings = await window.storageManager.getSettings();
    this.createCanvas();
  }

  createCanvas() {
    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('2d');
    this.canvas.style.display = 'none';
    document.body.appendChild(this.canvas);
  }

  async captureScreenshot() {
    console.log('ScreenshotManager: Starting screenshot capture');
    
    try {
      // Show fullscreen popup if enabled and in fullscreen
      this.showFullscreenPopup();
      
      // Step 1: Check if video is playing and pause it
      const video = this.findVideoElement();
      let wasPlaying = false;
      
      if (video && !video.paused) {
        wasPlaying = true;
        video.pause();
        console.log('ScreenshotManager: Video paused (was playing)');
      }

      // Step 2: Hide controls if auto-hide is enabled
      let hiddenElements = [];
      if (this.settings.autoHideControls) {
        hiddenElements = this.hideVideoControls();
        console.log('ScreenshotManager: Controls hidden');
      }

      // Step 3: Wait a moment for UI to settle
      const delay = this.settings.captureDelay || 100;
      await this.sleep(delay);

      // Step 4: Capture the screenshot
      const dataUrl = await this.captureVideoFrame(video);
      
      // Step 5: Restore hidden elements
      if (hiddenElements.length > 0) {
        this.restoreVideoControls(hiddenElements);
        console.log('ScreenshotManager: Controls restored');
      }

      // Step 6: Resume video if it was playing
      if (wasPlaying && video) {
        setTimeout(() => {
          video.play();
          console.log('ScreenshotManager: Video resumed');
        }, 200); // Small delay to ensure controls are restored
      }

      // Step 7: Process and download the screenshot
      if (dataUrl) {
        await this.processScreenshot(dataUrl);
        console.log('ScreenshotManager: Screenshot captured successfully');
      } else {
        throw new Error('Failed to capture screenshot');
      }

    } catch (error) {
      console.error('ScreenshotManager: Error capturing screenshot:', error);
      this.showNotification('Failed to capture screenshot: ' + error.message, 'error');
    }
  }

  findVideoElement() {
    // Try different selectors for various video sites
    const selectors = [
      // YouTube selectors
      '.video-stream',
      '.html5-video-player video',
      '#movie_player video',
      'video.video-stream',
      
      // Vimeo selectors
      '.vp-video',
      '.vp-video-wrapper video',
      '.player video',
      
      // Twitch selectors
      'video[data-a-target="video-player"]',
      '.video-player video',
      
      // Generic fallback
      'video'
    ];

    // First try to find playing videos
    for (const selector of selectors) {
      const videos = document.querySelectorAll(selector);
      for (const video of videos) {
        if (video && video.videoWidth && video.videoHeight && !video.paused) {
          console.log('Found playing video:', video);
          return video;
        }
      }
    }

    // Then try any video with dimensions
    for (const selector of selectors) {
      const videos = document.querySelectorAll(selector);
      for (const video of videos) {
        if (video && video.videoWidth && video.videoHeight) {
          console.log('Found video with dimensions:', video);
          return video;
        }
      }
    }

    // Finally try any video element
    const allVideos = document.querySelectorAll('video');
    for (const video of allVideos) {
      if (video && (video.videoWidth > 0 || video.clientWidth > 100)) {
        console.log('Found fallback video:', video);
        return video;
      }
    }

    console.log('No video element found');
    return null;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  hideVideoControls() {
    const hiddenElements = [];
    
    // YouTube specific selectors
    const youtubeSelectors = [
      '.ytp-chrome-top',
      '.ytp-chrome-bottom',
      '.ytp-gradient-top',
      '.ytp-gradient-bottom',
      '.ytp-title',
      '.ytp-watermark',
      '.ytp-ce-element',
      '.ytp-cards-teaser',
      '.ytp-endscreen-element'
    ];

    // Vimeo specific selectors
    const vimeoSelectors = [
      '.vp-controls',
      '.vp-title',
      '.vp-overlay'
    ];

    // Twitch specific selectors
    const twitchSelectors = [
      '.player-controls',
      '.player-overlay-background',
      '[data-a-target="player-overlay-click-handler"]'
    ];

    const allSelectors = [...youtubeSelectors, ...vimeoSelectors, ...twitchSelectors];

    allSelectors.forEach(selector => {
      const elements = document.querySelectorAll(selector);
      elements.forEach(element => {
        if (element && getComputedStyle(element).display !== 'none') {
          hiddenElements.push({
            element: element,
            originalDisplay: element.style.display,
            originalVisibility: element.style.visibility,
            originalOpacity: element.style.opacity
          });
          
          element.style.display = 'none';
        }
      });
    });

    return hiddenElements;
  }

  restoreVideoControls(hiddenElements) {
    hiddenElements.forEach(({ element, originalDisplay, originalVisibility, originalOpacity }) => {
      element.style.display = originalDisplay;
      element.style.visibility = originalVisibility;
      element.style.opacity = originalOpacity;
    });
  }

  async captureVideoFrame(video) {
    if (!video) {
      throw new Error('No video element found');
    }

    // Set canvas dimensions to match video
    this.canvas.width = video.videoWidth;
    this.canvas.height = video.videoHeight;

    // Draw video frame to canvas
    this.context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);

    // Convert to data URL
    return this.canvas.toDataURL('image/png', this.settings.screenshotQuality || 0.9);
  }

  async processScreenshot(dataUrl) {
    // Refresh settings to get latest title builder preferences
    await this.updateSettings();
    
    // Extract video metadata
    const metadata = this.extractVideoMetadata();
    
    const filename = this.generateCustomFilename(metadata, this.settings.filenameTemplate);
    
    console.log('Generated filename:', filename);
    
    // If annotation mode is enabled, show annotation interface
    if (this.settings.annotationMode) {
      this.showAnnotationInterface(dataUrl, filename);
    } else {
      // Direct download
      await this.downloadScreenshot(dataUrl, filename);
    }

    this.showNotification(`Screenshot saved as: ${filename}`, 'success');
  }

  async downloadScreenshot(dataUrl, filename) {
    try {
      // Generate folder path if folder organization is enabled
      let finalFilename = filename;
      if (this.settings.organizeFolders && this.settings.organizeFolders !== 'none') {
        const metadata = this.extractVideoMetadata();
        const folderPath = this.generateFolderPath(metadata);
        if (folderPath) {
          finalFilename = `${folderPath}/${filename}`;
        }
      }

      // Send message to background script to handle download
      const response = await chrome.runtime.sendMessage({
        action: 'downloadScreenshot',
        dataUrl: dataUrl,
        filename: finalFilename
      });

      if (!response.success) {
        throw new Error(response.error);
      }
    } catch (error) {
      console.error('Download failed:', error);
      // Fallback to direct download
      this.fallbackDownload(dataUrl, filename);
    }
  }

  generateFolderPath(metadata) {
    if (!this.settings.organizeFolders || this.settings.organizeFolders === 'none') {
      return '';
    }

    let folderName = '';
    
    switch (this.settings.organizeFolders) {
      case 'channel':
        folderName = metadata.channelName || 'Unknown Channel';
        break;
      case 'playlist':
        folderName = metadata.playlistName || metadata.channelName || 'No Playlist';
        break;
      case 'video':
        folderName = metadata.title || 'Unknown Video';
        break;
      case 'date':
        folderName = new Date().toISOString().split('T')[0];
        break;
      case 'channel-date':
        const channelName = metadata.channelName || 'Unknown Channel';
        const date = new Date().toISOString().split('T')[0];
        folderName = `${channelName}/${date}`;
        break;
      case 'custom':
        // Use custom folder pattern if specified
        if (this.settings.customFolderPattern) {
          folderName = this.applyTemplate(this.settings.customFolderPattern, metadata);
          // Remove .png extension that applyTemplate adds
          folderName = folderName.replace('.png', '');
        }
        break;
      default:
        return '';
    }

    // Clean folder name for file system compatibility
    folderName = folderName
      .replace(/[<>:"/\\|?*]/g, '_')
      .replace(/\s+/g, ' ')
      .trim()
      .substring(0, 100); // Limit folder name length

    return folderName;
  }

  fallbackDownload(dataUrl, filename) {
    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  showAnnotationInterface(dataUrl, filename) {
    // Create annotation overlay
    const overlay = document.createElement('div');
    overlay.className = 'screenshot-annotation-overlay';
    overlay.innerHTML = `
      <div class="annotation-container">
        <div class="annotation-header">
          <h3>Annotate Screenshot</h3>
          <button class="close-btn">&times;</button>
        </div>
        <div class="annotation-canvas-container">
          <canvas class="annotation-canvas"></canvas>
        </div>
        <div class="annotation-tools">
          <button class="tool-btn" data-tool="arrow">Arrow</button>
          <button class="tool-btn" data-tool="text">Text</button>
          <button class="tool-btn" data-tool="highlight">Highlight</button>
          <button class="tool-btn" data-tool="rectangle">Rectangle</button>
          <input type="color" class="color-picker" value="#ff0000">
          <button class="download-btn">Download</button>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);

    // Initialize annotation canvas
    const canvas = overlay.querySelector('.annotation-canvas');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
    };
    img.src = dataUrl;

    // Add event listeners for annotation tools
    this.setupAnnotationTools(overlay, canvas, filename);
  }

  setupAnnotationTools(overlay, canvas, filename) {
    const ctx = canvas.getContext('2d');
    let currentTool = 'arrow';
    let isDrawing = false;
    let startX, startY;

    // Tool selection
    overlay.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentTool = btn.dataset.tool;
        overlay.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Mouse events for drawing
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      // Draw based on current tool
      const color = overlay.querySelector('.color-picker').value;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      
      if (currentTool === 'arrow') {
        // Draw arrow logic here
        this.drawArrow(ctx, startX, startY, currentX, currentY);
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    // Download button
    overlay.querySelector('.download-btn').addEventListener('click', () => {
      const annotatedDataUrl = canvas.toDataURL('image/png');
      this.downloadScreenshot(annotatedDataUrl, filename);
      document.body.removeChild(overlay);
    });

    // Close button
    overlay.querySelector('.close-btn').addEventListener('click', () => {
      document.body.removeChild(overlay);
    });
  }

  drawArrow(ctx, fromX, fromY, toX, toY) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }

  showNotification(message, type = 'info') {
    // Remove any existing notifications first
    const existingNotifications = document.querySelectorAll('.screenshot-notification');
    existingNotifications.forEach(n => n.remove());

    const notification = document.createElement('div');
    notification.className = `screenshot-notification ${type}`;
    notification.textContent = message;
    
    // Use CSS classes instead of inline styles for better consistency
    document.body.appendChild(notification);

    // Trigger show animation
    setTimeout(() => {
      notification.classList.add('show');
    }, 100);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.classList.remove('show');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 400);
      }
    }, 3000);
  }

  // Show fullscreen popup with current shortcut key
  showFullscreenPopup() {
    // Only show if enabled and in fullscreen
    if (!this.settings.showFullscreenPopup || !this.isInFullscreen()) {
      return;
    }

    // Remove any existing popup
    const existingPopup = document.querySelector('.fullscreen-screenshot-popup');
    if (existingPopup) {
      existingPopup.remove();
    }

    // Get current shortcut key for display
    const shortcutKey = this.settings.fullscreenShortcut || 'shift+enter';
    let displayKey = shortcutKey;
    
    // Format key for display
    switch (shortcutKey.toLowerCase()) {
      case 'shift+enter':
        displayKey = 'Shift + Enter';
        break;
      case 'shift+space':
        displayKey = 'Shift + Spacebar';
        break;
      case 'enter':
        displayKey = 'Enter';
        break;
      case 'space':
        displayKey = 'Spacebar';
        break;
      default:
        displayKey = shortcutKey.replace('shift+', 'Shift + ').replace('key', '').toUpperCase();
    }

    // Create popup element
    const popup = document.createElement('div');
    popup.className = 'fullscreen-screenshot-popup';
    popup.innerHTML = `
      <div class="popup-content">
        <div class="popup-icon">ðŸ“¸</div>
        <div class="popup-text">Press <kbd>${displayKey}</kbd> to take screenshot</div>
        <button class="popup-close" title="Don't show again">Ã—</button>
      </div>
    `;

    // Add styles
    popup.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      backdrop-filter: blur(5px);
      animation: slideInRight 0.3s ease-out;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    `;

    // Add animation keyframes if not already added
    if (!document.querySelector('#fullscreen-popup-styles')) {
      const style = document.createElement('style');
      style.id = 'fullscreen-popup-styles';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        .fullscreen-screenshot-popup .popup-content {
          display: flex;
          align-items: center;
          gap: 10px;
        }
        .fullscreen-screenshot-popup .popup-icon {
          font-size: 18px;
        }
        .fullscreen-screenshot-popup kbd {
          background: rgba(255, 255, 255, 0.2);
          padding: 2px 6px;
          border-radius: 4px;
          font-weight: bold;
          border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .fullscreen-screenshot-popup .popup-close {
          background: none;
          border: none;
          color: white;
          font-size: 18px;
          cursor: pointer;
          padding: 0;
          margin-left: 10px;
          opacity: 0.7;
        }
        .fullscreen-screenshot-popup .popup-close:hover {
          opacity: 1;
        }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(popup);

    // Handle close button
    const closeBtn = popup.querySelector('.popup-close');
    closeBtn.addEventListener('click', () => {
      // Disable popup permanently
      this.settings.showFullscreenPopup = false;
      chrome.storage.sync.set({ showFullscreenPopup: false });
      popup.remove();
    });

    // Auto-hide after duration
    const duration = this.settings.fullscreenPopupDuration || 3000;
    setTimeout(() => {
      if (popup.parentNode) {
        popup.style.animation = 'slideInRight 0.3s ease-out reverse';
        setTimeout(() => {
          if (popup.parentNode) {
            popup.remove();
          }
        }, 300);
      }
    }, duration);
  }

  // Check if in fullscreen mode
  isInFullscreen() {
    return !!(
      document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement ||
      window.innerHeight === screen.height
    );
  }

  async updateSettings() {
    this.settings = await window.storageManager.getSettings();
  }

  // Video metadata extraction methods
  extractVideoMetadata() {
    const metadata = {
      title: this.getVideoTitle(),
      chapter: this.getCurrentChapter(),
      currentTime: this.getCurrentTime(),
      site: window.location.hostname,
      url: window.location.href,
      timestamp: new Date().toISOString(),
      channelName: this.getChannelName(),
      playlistName: this.getPlaylistName()
    };

    console.log('Extracted video metadata:', metadata);
    return metadata;
  }

  getVideoTitle() {
    const hostname = window.location.hostname;
    let title = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube title selectors (try multiple)
        const selectors = [
          'h1.ytd-video-primary-info-renderer',
          '.ytd-video-primary-info-renderer h1',
          'h1.style-scope.ytd-video-primary-info-renderer',
          '.ytp-title-text',
          '#container h1',
          'ytd-video-primary-info-renderer h1'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        // Fallback to page title
        if (!title) {
          title = document.title.replace(' - YouTube', '');
        }
      } else if (hostname.includes('vimeo.com')) {
        // Vimeo title selectors
        const selectors = [
          '.player_title',
          'h1[data-test-id="title"]',
          '.clip_info-wrapper h1',
          '.title'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        if (!title) {
          title = document.title.replace(' on Vimeo', '');
        }
      } else if (hostname.includes('twitch.tv')) {
        // Twitch title selectors
        const selectors = [
          '[data-a-target="stream-title"]',
          '.channel-info-content h2',
          '.tw-title'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        if (!title) {
          title = document.title.replace(' - Twitch', '');
        }
      } else {
        // Generic fallback
        title = document.title;
      }
    } catch (error) {
      console.warn('Error extracting video title:', error);
      title = document.title;
    }

    // Clean up title
    return title.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
  }

  getChannelName() {
    const hostname = window.location.hostname;
    let channelName = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube channel name selectors
        const selectors = [
          'ytd-channel-name a',
          '#channel-name a',
          '.ytd-channel-name a',
          'a.yt-simple-endpoint.style-scope.yt-formatted-string',
          '.ytd-video-owner-renderer .ytd-channel-name a',
          '#owner-text a',
          '.owner-text a'
        ];
        
        for (const selector of selectors) {
          const channelElement = document.querySelector(selector);
          if (channelElement && channelElement.textContent.trim()) {
            channelName = channelElement.textContent.trim();
            break;
          }
        }
      } else if (hostname.includes('vimeo.com')) {
        // Vimeo channel/user name selectors
        const selectors = [
          '.user-link',
          '.byline a',
          '[data-test-id="byline"] a'
        ];
        
        for (const selector of selectors) {
          const userElement = document.querySelector(selector);
          if (userElement && userElement.textContent.trim()) {
            channelName = userElement.textContent.trim();
            break;
          }
        }
      } else if (hostname.includes('twitch.tv')) {
        // Twitch channel name selectors
        const selectors = [
          '[data-a-target="user-display-name"]',
          '.channel-info-content h1',
          '.tw-title'
        ];
        
        for (const selector of selectors) {
          const channelElement = document.querySelector(selector);
          if (channelElement && channelElement.textContent.trim()) {
            channelName = channelElement.textContent.trim();
            break;
          }
        }
        
        // Extract from URL path
        if (!channelName) {
          const pathParts = window.location.pathname.split('/');
          if (pathParts.length > 1) {
            channelName = pathParts[1];
          }
        }
      }
    } catch (error) {
      console.warn('Error extracting channel name:', error);
    }

    // Clean up channel name
    return channelName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getPlaylistName() {
    const hostname = window.location.hostname;
    let playlistName = '';

    try {
      if (hostname.includes('youtube.com')) {
        // Check if we're in a playlist
        const urlParams = new URLSearchParams(window.location.search);
        const playlistId = urlParams.get('list');
        
        if (playlistId) {
          // Try to get playlist title from the page
          const playlistSelectors = [
            '.ytd-playlist-header-renderer h1',
            '.ytd-playlist-sidebar-renderer .title',
            '.playlist-title'
          ];
          
          for (const selector of playlistSelectors) {
            const playlistElement = document.querySelector(selector);
            if (playlistElement && playlistElement.textContent.trim()) {
              playlistName = playlistElement.textContent.trim();
              break;
            }
          }
        }
      }
    } catch (error) {
      console.warn('Error extracting playlist name:', error);
    }

    // Clean up playlist name
    return playlistName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getCurrentChapter() {
    const hostname = window.location.hostname;
    let chapter = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube chapter selectors
        const chapterSelectors = [
          '.ytp-chapter-title-content',
          '.ytp-chapter-title',
          '.ytd-macro-markers-list-item-renderer.iron-selected .ytd-macro-markers-list-item-renderer',
          '.ytp-progress-bar-container .ytp-chapter-title'
        ];
        
        for (const selector of chapterSelectors) {
          const chapterElement = document.querySelector(selector);
          if (chapterElement && chapterElement.textContent.trim()) {
            chapter = chapterElement.textContent.trim();
            break;
          }
        }
      }
      // Vimeo and Twitch don't typically have chapters
    } catch (error) {
      console.warn('Error extracting chapter:', error);
    }

    return chapter.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getCurrentTime() {
    try {
      const video = this.findVideoElement();
      if (video && !isNaN(video.currentTime)) {
        const time = Math.floor(video.currentTime);
        const hours = Math.floor(time / 3600);
        const minutes = Math.floor((time % 3600) / 60);
        const seconds = time % 60;
        
        if (hours > 0) {
          return `${hours.toString().padStart(2, '0')}-${minutes.toString().padStart(2, '0')}-${seconds.toString().padStart(2, '0')}`;
        } else {
          return `${minutes.toString().padStart(2, '0')}-${seconds.toString().padStart(2, '0')}`;
        }
      }
    } catch (error) {
      console.warn('Error getting current time:', error);
    }
    
    return '';
  }

  generateCustomFilename(metadata, template = null) {
    // If user has a custom template (advanced mode), use that
    if (template && template.trim()) {
      return this.applyTemplate(template, metadata);
    }
    
    // If filenameTemplate setting exists and not empty, use old template system
    if (this.settings.filenameTemplate && this.settings.filenameTemplate.trim()) {
      return this.applyTemplate(this.settings.filenameTemplate, metadata);
    }
    
    // Otherwise use the new title builder system
    const components = [];
    const separator = this.settings.titleSeparator || ' - ';
    
    if (this.settings.includeYoutube) {
      components.push('YouTube');
    }
    
    if (this.settings.includeChannelName && metadata.channelName) {
      const cleanChannel = metadata.channelName.replace(/[<>:"/\\|?*]/g, '').substring(0, 40);
      components.push(cleanChannel);
    }
    
    if (this.settings.includePlaylistName && metadata.playlistName) {
      const cleanPlaylist = metadata.playlistName.replace(/[<>:"/\\|?*]/g, '').substring(0, 40);
      components.push(cleanPlaylist);
    }
    
    if (this.settings.includeVideoTitle && metadata.title) {
      // Clean title for filename
      const cleanTitle = metadata.title.replace(/[<>:"/\\|?*]/g, '').substring(0, 50);
      components.push(cleanTitle);
    }
    
    if (this.settings.includeChapter && metadata.chapter) {
      const cleanChapter = metadata.chapter.replace(/[<>:"/\\|?*]/g, '').substring(0, 30);
      components.push(cleanChapter);
    }
    
    if (this.settings.includeTimestamp && metadata.currentTime) {
      components.push(metadata.currentTime);
    }
    
    if (this.settings.includeDate) {
      const date = new Date().toISOString().split('T')[0];
      components.push(date);
    }
    
    if (this.settings.includeTime) {
      const time = new Date().toTimeString().split(' ')[0].substring(0, 5).replace(':', '-');
      components.push(time);
    }
    
    let filename = components.join(separator) || 'youtube-screenshot';
    
    // Clean up filename and ensure it ends with .png
    filename = filename
      .replace(/[<>:"/\\|?*]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
      
    return filename + '.png';
  }

  fallbackDownload(dataUrl, filename) {
    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  showAnnotationInterface(dataUrl, filename) {
    // Create annotation overlay
    const overlay = document.createElement('div');
    overlay.className = 'screenshot-annotation-overlay';
    overlay.innerHTML = `
      <div class="annotation-container">
        <div class="annotation-header">
          <h3>Annotate Screenshot</h3>
          <button class="close-btn">&times;</button>
        </div>
        <div class="annotation-canvas-container">
          <canvas class="annotation-canvas"></canvas>
        </div>
        <div class="annotation-tools">
          <button class="tool-btn" data-tool="arrow">Arrow</button>
          <button class="tool-btn" data-tool="text">Text</button>
          <button class="tool-btn" data-tool="highlight">Highlight</button>
          <button class="tool-btn" data-tool="rectangle">Rectangle</button>
          <input type="color" class="color-picker" value="#ff0000">
          <button class="download-btn">Download</button>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);

    // Initialize annotation canvas
    const canvas = overlay.querySelector('.annotation-canvas');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
    };
    img.src = dataUrl;

    // Add event listeners for annotation tools
    this.setupAnnotationTools(overlay, canvas, filename);
  }

  setupAnnotationTools(overlay, canvas, filename) {
    const ctx = canvas.getContext('2d');
    let currentTool = 'arrow';
    let isDrawing = false;
    let startX, startY;

    // Tool selection
    overlay.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentTool = btn.dataset.tool;
        overlay.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Mouse events for drawing
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      // Draw based on current tool
      const color = overlay.querySelector('.color-picker').value;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      
      if (currentTool === 'arrow') {
        // Draw arrow logic here
        this.drawArrow(ctx, startX, startY, currentX, currentY);
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    // Download button
    overlay.querySelector('.download-btn').addEventListener('click', () => {
      const annotatedDataUrl = canvas.toDataURL('image/png');
      this.downloadScreenshot(annotatedDataUrl, filename);
      document.body.removeChild(overlay);
    });

    // Close button
    overlay.querySelector('.close-btn').addEventListener('click', () => {
      document.body.removeChild(overlay);
    });
  }

  drawArrow(ctx, fromX, fromY, toX, toY) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }

  showNotification(message, type = 'info') {
    // Remove any existing notifications first
    const existingNotifications = document.querySelectorAll('.screenshot-notification');
    existingNotifications.forEach(n => n.remove());

    const notification = document.createElement('div');
    notification.className = `screenshot-notification ${type}`;
    notification.textContent = message;
    
    // Use CSS classes instead of inline styles for better consistency
    document.body.appendChild(notification);

    // Trigger show animation
    setTimeout(() => {
      notification.classList.add('show');
    }, 100);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.classList.remove('show');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 400);
      }
    }, 3000);
  }

  // Show fullscreen popup with current shortcut key
  showFullscreenPopup() {
    // Only show if enabled and in fullscreen
    if (!this.settings.showFullscreenPopup || !this.isInFullscreen()) {
      return;
    }

    // Remove any existing popup
    const existingPopup = document.querySelector('.fullscreen-screenshot-popup');
    if (existingPopup) {
      existingPopup.remove();
    }

    // Get current shortcut key for display
    const shortcutKey = this.settings.fullscreenShortcut || 'shift+enter';
    let displayKey = shortcutKey;
    
    // Format key for display
    switch (shortcutKey.toLowerCase()) {
      case 'shift+enter':
        displayKey = 'Shift + Enter';
        break;
      case 'shift+space':
        displayKey = 'Shift + Spacebar';
        break;
      case 'enter':
        displayKey = 'Enter';
        break;
      case 'space':
        displayKey = 'Spacebar';
        break;
      default:
        displayKey = shortcutKey.replace('shift+', 'Shift + ').replace('key', '').toUpperCase();
    }

    // Create popup element
    const popup = document.createElement('div');
    popup.className = 'fullscreen-screenshot-popup';
    popup.innerHTML = `
      <div class="popup-content">
        <div class="popup-icon">ðŸ“¸</div>
        <div class="popup-text">Press <kbd>${displayKey}</kbd> to take screenshot</div>
        <button class="popup-close" title="Don't show again">Ã—</button>
      </div>
    `;

    // Add styles
    popup.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      backdrop-filter: blur(5px);
      animation: slideInRight 0.3s ease-out;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    `;

    // Add animation keyframes if not already added
    if (!document.querySelector('#fullscreen-popup-styles')) {
      const style = document.createElement('style');
      style.id = 'fullscreen-popup-styles';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        .fullscreen-screenshot-popup .popup-content {
          display: flex;
          align-items: center;
          gap: 10px;
        }
        .fullscreen-screenshot-popup .popup-icon {
          font-size: 18px;
        }
        .fullscreen-screenshot-popup kbd {
          background: rgba(255, 255, 255, 0.2);
          padding: 2px 6px;
          border-radius: 4px;
          font-weight: bold;
          border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .fullscreen-screenshot-popup .popup-close {
          background: none;
          border: none;
          color: white;
          font-size: 18px;
          cursor: pointer;
          padding: 0;
          margin-left: 10px;
          opacity: 0.7;
        }
        .fullscreen-screenshot-popup .popup-close:hover {
          opacity: 1;
        }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(popup);

    // Handle close button
    const closeBtn = popup.querySelector('.popup-close');
    closeBtn.addEventListener('click', () => {
      // Disable popup permanently
      this.settings.showFullscreenPopup = false;
      chrome.storage.sync.set({ showFullscreenPopup: false });
      popup.remove();
    });

    // Auto-hide after duration
    const duration = this.settings.fullscreenPopupDuration || 3000;
    setTimeout(() => {
      if (popup.parentNode) {
        popup.style.animation = 'slideInRight 0.3s ease-out reverse';
        setTimeout(() => {
          if (popup.parentNode) {
            popup.remove();
          }
        }, 300);
      }
    }, duration);
  }

  // Check if in fullscreen mode
  isInFullscreen() {
    return !!(
      document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement ||
      window.innerHeight === screen.height
    );
  }

  async updateSettings() {
    this.settings = await window.storageManager.getSettings();
  }

  // Video metadata extraction methods
  extractVideoMetadata() {
    const metadata = {
      title: this.getVideoTitle(),
      chapter: this.getCurrentChapter(),
      currentTime: this.getCurrentTime(),
      site: window.location.hostname,
      url: window.location.href,
      timestamp: new Date().toISOString(),
      channelName: this.getChannelName(),
      playlistName: this.getPlaylistName()
    };

    console.log('Extracted video metadata:', metadata);
    return metadata;
  }

  getVideoTitle() {
    const hostname = window.location.hostname;
    let title = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube title selectors (try multiple)
        const selectors = [
          'h1.ytd-video-primary-info-renderer',
          '.ytd-video-primary-info-renderer h1',
          'h1.style-scope.ytd-video-primary-info-renderer',
          '.ytp-title-text',
          '#container h1',
          'ytd-video-primary-info-renderer h1'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        // Fallback to page title
        if (!title) {
          title = document.title.replace(' - YouTube', '');
        }
      } else if (hostname.includes('vimeo.com')) {
        // Vimeo title selectors
        const selectors = [
          '.player_title',
          'h1[data-test-id="title"]',
          '.clip_info-wrapper h1',
          '.title'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        if (!title) {
          title = document.title.replace(' on Vimeo', '');
        }
      } else if (hostname.includes('twitch.tv')) {
        // Twitch title selectors
        const selectors = [
          '[data-a-target="stream-title"]',
          '.channel-info-content h2',
          '.tw-title'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        if (!title) {
          title = document.title.replace(' - Twitch', '');
        }
      } else {
        // Generic fallback
        title = document.title;
      }
    } catch (error) {
      console.warn('Error extracting video title:', error);
      title = document.title;
    }

    // Clean up title
    return title.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
  }

  getChannelName() {
    const hostname = window.location.hostname;
    let channelName = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube channel name selectors
        const selectors = [
          'ytd-channel-name a',
          '#channel-name a',
          '.ytd-channel-name a',
          'a.yt-simple-endpoint.style-scope.yt-formatted-string',
          '.ytd-video-owner-renderer .ytd-channel-name a',
          '#owner-text a',
          '.owner-text a'
        ];
        
        for (const selector of selectors) {
          const channelElement = document.querySelector(selector);
          if (channelElement && channelElement.textContent.trim()) {
            channelName = channelElement.textContent.trim();
            break;
          }
        }
      } else if (hostname.includes('vimeo.com')) {
        // Vimeo channel/user name selectors
        const selectors = [
          '.user-link',
          '.byline a',
          '[data-test-id="byline"] a'
        ];
        
        for (const selector of selectors) {
          const userElement = document.querySelector(selector);
          if (userElement && userElement.textContent.trim()) {
            channelName = userElement.textContent.trim();
            break;
          }
        }
      } else if (hostname.includes('twitch.tv')) {
        // Twitch channel name selectors
        const selectors = [
          '[data-a-target="user-display-name"]',
          '.channel-info-content h1',
          '.tw-title'
        ];
        
        for (const selector of selectors) {
          const channelElement = document.querySelector(selector);
          if (channelElement && channelElement.textContent.trim()) {
            channelName = channelElement.textContent.trim();
            break;
          }
        }
        
        // Extract from URL path
        if (!channelName) {
          const pathParts = window.location.pathname.split('/');
          if (pathParts.length > 1) {
            channelName = pathParts[1];
          }
        }
      }
    } catch (error) {
      console.warn('Error extracting channel name:', error);
    }

    // Clean up channel name
    return channelName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getPlaylistName() {
    const hostname = window.location.hostname;
    let playlistName = '';

    try {
      if (hostname.includes('youtube.com')) {
        // Check if we're in a playlist
        const urlParams = new URLSearchParams(window.location.search);
        const playlistId = urlParams.get('list');
        
        if (playlistId) {
          // Try to get playlist title from the page
          const playlistSelectors = [
            '.ytd-playlist-header-renderer h1',
            '.ytd-playlist-sidebar-renderer .title',
            '.playlist-title'
          ];
          
          for (const selector of playlistSelectors) {
            const playlistElement = document.querySelector(selector);
            if (playlistElement && playlistElement.textContent.trim()) {
              playlistName = playlistElement.textContent.trim();
              break;
            }
          }
        }
      }
    } catch (error) {
      console.warn('Error extracting playlist name:', error);
    }

    // Clean up playlist name
    return playlistName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getCurrentChapter() {
    const hostname = window.location.hostname;
    let chapter = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube chapter selectors
        const chapterSelectors = [
          '.ytp-chapter-title-content',
          '.ytp-chapter-title',
          '.ytd-macro-markers-list-item-renderer.iron-selected .ytd-macro-markers-list-item-renderer',
          '.ytp-progress-bar-container .ytp-chapter-title'
        ];
        
        for (const selector of chapterSelectors) {
          const chapterElement = document.querySelector(selector);
          if (chapterElement && chapterElement.textContent.trim()) {
            chapter = chapterElement.textContent.trim();
            break;
          }
        }
      }
      // Vimeo and Twitch don't typically have chapters
    } catch (error) {
      console.warn('Error extracting chapter:', error);
    }

    return chapter.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getCurrentTime() {
    try {
      const video = this.findVideoElement();
      if (video && !isNaN(video.currentTime)) {
        const time = Math.floor(video.currentTime);
        const hours = Math.floor(time / 3600);
        const minutes = Math.floor((time % 3600) / 60);
        const seconds = time % 60;
        
        if (hours > 0) {
          return `${hours.toString().padStart(2, '0')}-${minutes.toString().padStart(2, '0')}-${seconds.toString().padStart(2, '0')}`;
        } else {
          return `${minutes.toString().padStart(2, '0')}-${seconds.toString().padStart(2, '0')}`;
        }
      }
    } catch (error) {
      console.warn('Error getting current time:', error);
    }
    
    return '';
  }

  generateCustomFilename(metadata, template = null) {
    // If user has a custom template (advanced mode), use that
    if (template && template.trim()) {
      return this.applyTemplate(template, metadata);
    }
    
    // If filenameTemplate setting exists and not empty, use old template system
    if (this.settings.filenameTemplate && this.settings.filenameTemplate.trim()) {
      return this.applyTemplate(this.settings.filenameTemplate, metadata);
    }
    
    // Otherwise use the new title builder system
    const components = [];
    const separator = this.settings.titleSeparator || ' - ';
    
    if (this.settings.includeYoutube) {
      components.push('YouTube');
    }
    
    if (this.settings.includeChannelName && metadata.channelName) {
      const cleanChannel = metadata.channelName.replace(/[<>:"/\\|?*]/g, '').substring(0, 40);
      components.push(cleanChannel);
    }
    
    if (this.settings.includePlaylistName && metadata.playlistName) {
      const cleanPlaylist = metadata.playlistName.replace(/[<>:"/\\|?*]/g, '').substring(0, 40);
      components.push(cleanPlaylist);
    }
    
    if (this.settings.includeVideoTitle && metadata.title) {
      // Clean title for filename
      const cleanTitle = metadata.title.replace(/[<>:"/\\|?*]/g, '').substring(0, 50);
      components.push(cleanTitle);
    }
    
    if (this.settings.includeChapter && metadata.chapter) {
      const cleanChapter = metadata.chapter.replace(/[<>:"/\\|?*]/g, '').substring(0, 30);
      components.push(cleanChapter);
    }
    
    if (this.settings.includeTimestamp && metadata.currentTime) {
      components.push(metadata.currentTime);
    }
    
    if (this.settings.includeDate) {
      const date = new Date().toISOString().split('T')[0];
      components.push(date);
    }
    
    if (this.settings.includeTime) {
      const time = new Date().toTimeString().split(' ')[0].substring(0, 5).replace(':', '-');
      components.push(time);
    }
    
    let filename = components.join(separator) || 'youtube-screenshot';
    
    // Clean up filename and ensure it ends with .png
    filename = filename
      .replace(/[<>:"/\\|?*]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
      
    return filename + '.png';
  }

  fallbackDownload(dataUrl, filename) {
    const link = document.createElement('a');
    link.download = filename;
    link.href = dataUrl;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  showAnnotationInterface(dataUrl, filename) {
    // Create annotation overlay
    const overlay = document.createElement('div');
    overlay.className = 'screenshot-annotation-overlay';
    overlay.innerHTML = `
      <div class="annotation-container">
        <div class="annotation-header">
          <h3>Annotate Screenshot</h3>
          <button class="close-btn">&times;</button>
        </div>
        <div class="annotation-canvas-container">
          <canvas class="annotation-canvas"></canvas>
        </div>
        <div class="annotation-tools">
          <button class="tool-btn" data-tool="arrow">Arrow</button>
          <button class="tool-btn" data-tool="text">Text</button>
          <button class="tool-btn" data-tool="highlight">Highlight</button>
          <button class="tool-btn" data-tool="rectangle">Rectangle</button>
          <input type="color" class="color-picker" value="#ff0000">
          <button class="download-btn">Download</button>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);

    // Initialize annotation canvas
    const canvas = overlay.querySelector('.annotation-canvas');
    const img = new Image();
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
    };
    img.src = dataUrl;

    // Add event listeners for annotation tools
    this.setupAnnotationTools(overlay, canvas, filename);
  }

  setupAnnotationTools(overlay, canvas, filename) {
    const ctx = canvas.getContext('2d');
    let currentTool = 'arrow';
    let isDrawing = false;
    let startX, startY;

    // Tool selection
    overlay.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        currentTool = btn.dataset.tool;
        overlay.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Mouse events for drawing
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      
      // Draw based on current tool
      const color = overlay.querySelector('.color-picker').value;
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      
      if (currentTool === 'arrow') {
        // Draw arrow logic here
        this.drawArrow(ctx, startX, startY, currentX, currentY);
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    // Download button
    overlay.querySelector('.download-btn').addEventListener('click', () => {
      const annotatedDataUrl = canvas.toDataURL('image/png');
      this.downloadScreenshot(annotatedDataUrl, filename);
      document.body.removeChild(overlay);
    });

    // Close button
    overlay.querySelector('.close-btn').addEventListener('click', () => {
      document.body.removeChild(overlay);
    });
  }

  drawArrow(ctx, fromX, fromY, toX, toY) {
    const headlen = 10;
    const angle = Math.atan2(toY - fromY, toX - fromX);

    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }

  showNotification(message, type = 'info') {
    // Remove any existing notifications first
    const existingNotifications = document.querySelectorAll('.screenshot-notification');
    existingNotifications.forEach(n => n.remove());

    const notification = document.createElement('div');
    notification.className = `screenshot-notification ${type}`;
    notification.textContent = message;
    
    // Use CSS classes instead of inline styles for better consistency
    document.body.appendChild(notification);

    // Trigger show animation
    setTimeout(() => {
      notification.classList.add('show');
    }, 100);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.classList.remove('show');
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 400);
      }
    }, 3000);
  }

  // Show fullscreen popup with current shortcut key
  showFullscreenPopup() {
    // Only show if enabled and in fullscreen
    if (!this.settings.showFullscreenPopup || !this.isInFullscreen()) {
      return;
    }

    // Remove any existing popup
    const existingPopup = document.querySelector('.fullscreen-screenshot-popup');
    if (existingPopup) {
      existingPopup.remove();
    }

    // Get current shortcut key for display
    const shortcutKey = this.settings.fullscreenShortcut || 'shift+enter';
    let displayKey = shortcutKey;
    
    // Format key for display
    switch (shortcutKey.toLowerCase()) {
      case 'shift+enter':
        displayKey = 'Shift + Enter';
        break;
      case 'shift+space':
        displayKey = 'Shift + Spacebar';
        break;
      case 'enter':
        displayKey = 'Enter';
        break;
      case 'space':
        displayKey = 'Spacebar';
        break;
      default:
        displayKey = shortcutKey.replace('shift+', 'Shift + ').replace('key', '').toUpperCase();
    }

    // Create popup element
    const popup = document.createElement('div');
    popup.className = 'fullscreen-screenshot-popup';
    popup.innerHTML = `
      <div class="popup-content">
        <div class="popup-icon">ðŸ“¸</div>
        <div class="popup-text">Press <kbd>${displayKey}</kbd> to take screenshot</div>
        <button class="popup-close" title="Don't show again">Ã—</button>
      </div>
    `;

    // Add styles
    popup.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 10000;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 20px;
      border-radius: 8px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 14px;
      backdrop-filter: blur(5px);
      animation: slideInRight 0.3s ease-out;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    `;

    // Add animation keyframes if not already added
    if (!document.querySelector('#fullscreen-popup-styles')) {
      const style = document.createElement('style');
      style.id = 'fullscreen-popup-styles';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        .fullscreen-screenshot-popup .popup-content {
          display: flex;
          align-items: center;
          gap: 10px;
        }
        .fullscreen-screenshot-popup .popup-icon {
          font-size: 18px;
        }
        .fullscreen-screenshot-popup kbd {
          background: rgba(255, 255, 255, 0.2);
          padding: 2px 6px;
          border-radius: 4px;
          font-weight: bold;
          border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .fullscreen-screenshot-popup .popup-close {
          background: none;
          border: none;
          color: white;
          font-size: 18px;
          cursor: pointer;
          padding: 0;
          margin-left: 10px;
          opacity: 0.7;
        }
        .fullscreen-screenshot-popup .popup-close:hover {
          opacity: 1;
        }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(popup);

    // Handle close button
    const closeBtn = popup.querySelector('.popup-close');
    closeBtn.addEventListener('click', () => {
      // Disable popup permanently
      this.settings.showFullscreenPopup = false;
      chrome.storage.sync.set({ showFullscreenPopup: false });
      popup.remove();
    });

    // Auto-hide after duration
    const duration = this.settings.fullscreenPopupDuration || 3000;
    setTimeout(() => {
      if (popup.parentNode) {
        popup.style.animation = 'slideInRight 0.3s ease-out reverse';
        setTimeout(() => {
          if (popup.parentNode) {
            popup.remove();
          }
        }, 300);
      }
    }, duration);
  }

  // Check if in fullscreen mode
  isInFullscreen() {
    return !!(
      document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.mozFullScreenElement ||
      document.msFullscreenElement ||
      window.innerHeight === screen.height
    );
  }

  async updateSettings() {
    this.settings = await window.storageManager.getSettings();
  }

  // Video metadata extraction methods
  extractVideoMetadata() {
    const metadata = {
      title: this.getVideoTitle(),
      chapter: this.getCurrentChapter(),
      currentTime: this.getCurrentTime(),
      site: window.location.hostname,
      url: window.location.href,
      timestamp: new Date().toISOString(),
      channelName: this.getChannelName(),
      playlistName: this.getPlaylistName()
    };

    console.log('Extracted video metadata:', metadata);
    return metadata;
  }

  getVideoTitle() {
    const hostname = window.location.hostname;
    let title = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube title selectors (try multiple)
        const selectors = [
          'h1.ytd-video-primary-info-renderer',
          '.ytd-video-primary-info-renderer h1',
          'h1.style-scope.ytd-video-primary-info-renderer',
          '.ytp-title-text',
          '#container h1',
          'ytd-video-primary-info-renderer h1'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        // Fallback to page title
        if (!title) {
          title = document.title.replace(' - YouTube', '');
        }
      } else if (hostname.includes('vimeo.com')) {
        // Vimeo title selectors
        const selectors = [
          '.player_title',
          'h1[data-test-id="title"]',
          '.clip_info-wrapper h1',
          '.title'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        if (!title) {
          title = document.title.replace(' on Vimeo', '');
        }
      } else if (hostname.includes('twitch.tv')) {
        // Twitch title selectors
        const selectors = [
          '[data-a-target="stream-title"]',
          '.channel-info-content h2',
          '.tw-title'
        ];
        
        for (const selector of selectors) {
          const titleElement = document.querySelector(selector);
          if (titleElement && titleElement.textContent.trim()) {
            title = titleElement.textContent.trim();
            break;
          }
        }
        
        if (!title) {
          title = document.title.replace(' - Twitch', '');
        }
      } else {
        // Generic fallback
        title = document.title;
      }
    } catch (error) {
      console.warn('Error extracting video title:', error);
      title = document.title;
    }

    // Clean up title
    return title.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
  }

  getChannelName() {
    const hostname = window.location.hostname;
    let channelName = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube channel name selectors
        const selectors = [
          'ytd-channel-name a',
          '#channel-name a',
          '.ytd-channel-name a',
          'a.yt-simple-endpoint.style-scope.yt-formatted-string',
          '.ytd-video-owner-renderer .ytd-channel-name a',
          '#owner-text a',
          '.owner-text a'
        ];
        
        for (const selector of selectors) {
          const channelElement = document.querySelector(selector);
          if (channelElement && channelElement.textContent.trim()) {
            channelName = channelElement.textContent.trim();
            break;
          }
        }
      } else if (hostname.includes('vimeo.com')) {
        // Vimeo channel/user name selectors
        const selectors = [
          '.user-link',
          '.byline a',
          '[data-test-id="byline"] a'
        ];
        
        for (const selector of selectors) {
          const userElement = document.querySelector(selector);
          if (userElement && userElement.textContent.trim()) {
            channelName = userElement.textContent.trim();
            break;
          }
        }
      } else if (hostname.includes('twitch.tv')) {
        // Twitch channel name selectors
        const selectors = [
          '[data-a-target="user-display-name"]',
          '.channel-info-content h1',
          '.tw-title'
        ];
        
        for (const selector of selectors) {
          const channelElement = document.querySelector(selector);
          if (channelElement && channelElement.textContent.trim()) {
            channelName = channelElement.textContent.trim();
            break;
          }
        }
        
        // Extract from URL path
        if (!channelName) {
          const pathParts = window.location.pathname.split('/');
          if (pathParts.length > 1) {
            channelName = pathParts[1];
          }
        }
      }
    } catch (error) {
      console.warn('Error extracting channel name:', error);
    }

    // Clean up channel name
    return channelName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getPlaylistName() {
    const hostname = window.location.hostname;
    let playlistName = '';

    try {
      if (hostname.includes('youtube.com')) {
        // Check if we're in a playlist
        const urlParams = new URLSearchParams(window.location.search);
        const playlistId = urlParams.get('list');
        
        if (playlistId) {
          // Try to get playlist title from the page
          const playlistSelectors = [
            '.ytd-playlist-header-renderer h1',
            '.ytd-playlist-sidebar-renderer .title',
            '.playlist-title'
          ];
          
          for (const selector of playlistSelectors) {
            const playlistElement = document.querySelector(selector);
            if (playlistElement && playlistElement.textContent.trim()) {
              playlistName = playlistElement.textContent.trim();
              break;
            }
          }
        }
      }
    } catch (error) {
      console.warn('Error extracting playlist name:', error);
    }

    // Clean up playlist name
    return playlistName.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getCurrentChapter() {
    const hostname = window.location.hostname;
    let chapter = '';

    try {
      if (hostname.includes('youtube.com')) {
        // YouTube chapter selectors
        const chapterSelectors = [
          '.ytp-chapter-title-content',
          '.ytp-chapter-title',
          '.ytd-macro-markers-list-item-renderer.iron-selected .ytd-macro-markers-list-item-renderer',
          '.ytp-progress-bar-container .ytp-chapter-title'
        ];
        
        for (const selector of chapterSelectors) {
          const chapterElement = document.querySelector(selector);
          if (chapterElement && chapterElement.textContent.trim()) {
            chapter = chapterElement.textContent.trim();
            break;
          }
        }
      }
      // Vimeo and Twitch don't typically have chapters
    } catch (error) {
      console.warn('Error extracting chapter:', error);
    }

    return chapter.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50);
  }

  getCurrentTime() {
    try {
      const video = this.findVideoElement();
      if (video && !isNaN(video.currentTime)) {
        const time = Math.floor(video.currentTime);
        const hours = Math.floor(time / 3600);
        const minutes = Math.floor((time % 3600) / 60);
        const seconds = time % 60;
        
        if (hours > 0) {
          return `${hours.toString().padStart(2, '0')}-${minutes.toString().padStart(2, '0')}-${seconds.toString().padStart(2, '0')}`;
        } else {
          return `${minutes.toString().padStart(2, '0')}-${seconds.toString().padStart(2, '0')}`;
        }
      }
    } catch (error) {
      console.warn('Error getting current time:', error);
    }
    
    return '';
  }

  generateCustomFilename(metadata, template = null) {
    // If user has a custom template (advanced mode), use that
    if (template && template.trim()) {
      return this.applyTemplate(template, metadata);
    }
    
    // If filenameTemplate setting exists and not empty, use old template system
    if (this.settings.filenameTemplate && this.settings.filenameTemplate.trim()) {
      return this.applyTemplate(this.settings.filenameTemplate, metadata);
    }
    
    // Otherwise use the new title builder system
    const components = [];
    const separator = this.settings.titleSeparator || ' - ';
    
    if (this.settings.includeYoutube) {
      components.push('YouTube');
    }
    
    if (this.settings.includeChannelName && metadata.channelName) {
      const cleanChannel = metadata.channelName.replace(/[<>:"/\\|?*]/g, '').substring(0, 40);
      components.push(cleanChannel);
    }
    
    if (this.settings.includePlaylistName && metadata.playlistName) {
      const cleanPlaylist = metadata.playlistName.replace(/[<>:"/\\|?*]/g, '').substring(0, 40);
      components.push(cleanPlaylist);
    }
    
    if (this.settings.includeVideoTitle && metadata.title) {
      // Clean title for filename
      const cleanTitle = metadata.title.replace(/[<>:"/\\|?*]/g, '').substring(0, 50);
      components.push(cleanTitle);
    }
    
    if (this.settings.includeChapter && metadata.chapter) {
      const cleanChapter = metadata.chapter.replace(/[<>:"/\\|?*]/g, '').substring(0, 30);
      components.push(cleanChapter);
    }
    
    if (this.settings.includeTimestamp && metadata.currentTime) {
      components.push(metadata.currentTime);
    }
    
    if (this.settings.includeDate) {
      const date = new Date().toISOString().split('T')[0];
      components.push(date);
    }
    
    if (this.settings.includeTime) {
      const time = new Date().toTimeString().split(' ')[0].substring(0, 5).replace(':', '-');
      components.push(time);
    }
    
    let filename = components.join(separator) || 'youtube-screenshot';
    
    // Clean up filename and ensure it ends with .png
    filename = filename
      .replace(/[<>:"/\\|?*]/g, '')
      .replace(/\s+/g, ' ')
      .trim();
      
    return filename + '.png';
  }

  generateFolderPath(metadata) {
    if (!this.settings.organizeFolders || this.settings.organizeFolders === 'none') {
      return '';
    }

    let folderName = '';
    
    switch (this.settings.organizeFolders) {
      case 'channel':
        folderName = metadata.channelName || 'Unknown Channel';
        break;
      case 'playlist':
        folderName = metadata.playlistName || metadata.channelName || 'No Playlist';
        break;
      case 'video':
        folderName = metadata.title || 'Unknown Video';
        break;
      case 'date':
        folderName = new Date().toISOString().split('T')[0];
        break;
      case 'channel-date':
        const channelName = metadata.channelName || 'Unknown Channel';
        const date = new Date().toISOString().split('T')[0];
        folderName = `${channelName}/${date}`;
        break;
      case 'custom':
        // Use custom folder pattern if specified
        if (this.settings.customFolderPattern) {
          folderName = this.applyTemplate(this.settings.customFolderPattern, metadata);
          // Remove .png extension that applyTemplate adds
          folderName = folderName.replace('.png', '');
        }
        break;
      default:
        return '';
    }

    // Clean folder name for file system compatibility
    folderName = folderName
      .replace(/[<>:"/\\|?*]/g, '_')
      .replace(/\s+/g, ' ')
      .trim()
      .substring(0, 100); // Limit folder name length

    return folderName;
  }

  applyTemplate(template, metadata) {
    const now = new Date();
    
    const replacements = {
      '{site}': metadata.site.replace(/[<>:"/\\|?*]/g, '_'),
      '{title}': metadata.title || 'video',
      '{chapter}': metadata.chapter || '',
      '{timestamp}': metadata.currentTime || '',
      '{date}': now.toISOString().split('T')[0],
      '{time}': now.toTimeString().split(' ')[0].substring(0, 5).replace(':', '-'),
      '{datetime}': now.toISOString().replace('T', '_').replace(/[:.]/g, '-').split('.')[0],
      '{year}': now.getFullYear().toString(),
      '{month}': (now.getMonth() + 1).toString().padStart(2, '0'),
      '{day}': now.getDate().toString().padStart(2, '0'),
      '{hour}': now.getHours().toString().padStart(2, '0'),
      '{minute}': now.getMinutes().toString().padStart(2, '0'),
      '{second}': now.getSeconds().toString().padStart(2, '0'),
      // New template variables
      '{channel}': metadata.channelName || '',
      '{playlist}': metadata.playlistName || ''
    };

    let filename = template;
    Object.entries(replacements).forEach(([placeholder, value]) => {
      filename = filename.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), value || '');
    });

    // Clean up consecutive separators and ensure it ends with .png
    filename = filename
      .replace(/[-_\s]+/g, '-')
      .replace(/^[-_\s]+|[-_\s]+$/g, '')
      .replace(/\.png$/, '') + '.png';

    return filename;
  }
}

// Initialize screenshot manager when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.screenshotManager = new ScreenshotManager();
  });
} else {
  window.screenshotManager = new ScreenshotManager();
}
